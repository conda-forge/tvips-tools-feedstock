--- tvips/dan_test.c.orig
+++ tvips/dan_test.c
@@ -71,8 +71,6 @@ main(int argc, char *argv[])
      *
      * XXX Think about different multipliers!
      */
-    float multiplier = 4.0 / 3.0;
-    int32_t offset = -9500;
     uint64_t sum = 0;
 
     if (frame->width != bkg->width || frame->height != bkg->height)
@@ -99,7 +97,7 @@ main(int argc, char *argv[])
     }
     frame_free(bkg);
 
-    fprintf(stderr, "Average intensity %zd\n", sum / (frame->width * frame->height));
+    fprintf(stderr, "Average intensity %llu\n", (unsigned long long int)(sum / (frame->width * frame->height)));
 
 
     /* Write the output file.
--- tvips/dumpframe.c.orig
+++ tvips/dumpframe.c
@@ -3147,6 +3147,7 @@ main(int argc, char *argv[])
                      * XXX This code should (but does not) set @c
                      * errno properly.
                      */
+                    alpha_prev = NAN;
                     item = metadata_find(dict_sub, "App defined");
                     if (item != NULL && item->type == metadata_type_int32) {
                         app_defined = fmodf(1e-3 * item->value.int32, 360);
--- tvips/fixpoint.c.orig
+++ tvips/fixpoint.c
@@ -400,8 +400,8 @@ programmatic2(const struct timespec *base, size_t nmemb)
                  */
 //                printf("%02zd: BREAKAGE UNDERSHOOT not in [%f, %f] %zd\n",
 //                       i, offset_min[i], offset_max[i], k_cur);
-                printf("%02zd: BREAKAGE UNDERSHOOT %ld not in [%f, %f] %zd\n",
-                       i, base[i].tv_sec, offset_min + k[i] * p_min, offset_max + k[i] * p_max, k_cur);
+                printf("%02zd: BREAKAGE UNDERSHOOT %lld not in [%f, %f] %zd\n",
+                       i, (long long int)base[i].tv_sec, offset_min + k[i] * p_min, offset_max + k[i] * p_max, k_cur);
                 for (j = i; j < nmemb; j++)
                     k[j] += 1;
                 ok = 0;
@@ -445,9 +445,9 @@ programmatic2(const struct timespec *base, size_t nmemb)
             offset_max = MIN(offset_max, o_max);
 
 
-            printf("\n    %02zd: CHECK %ld %ld %zd %f [%f]\n",
+            printf("\n    %02zd: CHECK %lld %lld %zd %f [%f]\n",
                    i,
-                   base[i].tv_sec, base[0].tv_sec, k[i], p_max, o_min);
+                   (long long int)base[i].tv_sec, (long long int)base[0].tv_sec, k[i], p_max, o_min);
 
             printf("    %02zd: LIMITS [%f, %f] [%f, %f] [%f, %f]\n",
                    i,
@@ -680,14 +680,14 @@ main(int argc, char *argv[])
     seq = calloc(N, sizeof(struct timespec));
     if (seq == NULL)
         err(EXIT_FAILURE, "Could not allocate sequence");
-    for (i = 0; i < N; i++) {
+    for (i = j = 0; i < N; i++) {
 //        if (1.0f * random() / RAND_MAX >= skip) {
 //        if (i != 2) { // This will undershoot
         if (i != 2 && i != 3 && i != 4) { // This will overshoot
             seq[j].tv_sec = lrintf(floorf(period * i + offset));
             seq[j].tv_nsec = 0;
 
-            printf(" ### %3zd: %ld\n", j, seq[j].tv_sec);
+            printf(" ### %3zd: %lld\n", j, (long long int)seq[j].tv_sec);
             j += 1;
         }
     }
--- tvips/img2px.c.orig
+++ tvips/img2px.c
@@ -1274,6 +1274,8 @@ _histogram(struct frame *frame, size_t counter, void *data)
         double stddev;
 
         mode = histogram->HHF + 1;
+        n_stddev = 0;
+        stddev = 0;
         for (i = histogram->HHF + 2; i < 2 * histogram->HHF; i++) {
             if (histogram->histogram[i] > histogram->histogram[mode]) {
                 mode = i;
--- tvips/tiff.c.orig
+++ tvips/tiff.c
@@ -244,15 +244,15 @@ _tiff_write(thandle_t handle, tdata_t ptr, tsize_t size)
  *            otherwise
  */
 static uint16_t *
-_tiff_cpy(uint32 w,
-          uint32 l,
-          uint16 bps,
+_tiff_cpy(uint32_t w,
+          uint32_t l,
+          uint16_t bps,
           uint16_t *dst,
-          int32 ldd,
+          int32_t ldd,
           const void *src,
-          uint32 lds)
+          uint32_t lds)
 {
-    uint32 i, j;
+    uint32_t i, j;
 
     switch (bps) {
     case 8:
@@ -261,7 +261,7 @@ _tiff_cpy(uint32 w,
          */
         for (i = 0; i < l; i++) {
             for (j = 0; j < w; j++)
-                dst[ldd * i + j] = ((const uint8 *)src)[lds * i + j];
+                dst[ldd * i + j] = ((const uint8_t *)src)[lds * i + j];
         }
         return (dst);
 
@@ -271,7 +271,7 @@ _tiff_cpy(uint32 w,
          */
         for (i = 0; i < l; i++) {
             for (j = 0; j < w; j++)
-                dst[ldd * i + j] = ((const uint16 *)src)[lds * i + j];
+                dst[ldd * i + j] = ((const uint16_t *)src)[lds * i + j];
         }
         return (dst);
     }
@@ -305,13 +305,13 @@ _tiff_cpy(uint32 w,
  * @return         Decoded raster, pass to free(3)
  */
 static uint16_t *
-_tiff_raster(TIFF *tif, uint32 *w, uint32 *l, uint16 *bps)
+_tiff_raster(TIFF *tif, uint32_t *w, uint32_t *l, uint16_t *bps)
 {
     uint16_t *raster;
     tdata_t src_data;
     tsize_t src_size;
-    uint32 d, i, j, tl, tw;
-    uint16 cfg, spp, sf, pm;
+    uint32_t d, i, j, tl, tw;
+    uint16_t cfg, spp, sf, pm;
 
     raster = NULL;
     src_data = NULL;
@@ -640,6 +640,7 @@ tvips_ctime_tiff(
      * where the image was written.  According to Peter Sparlinek, the
      * timestamp is nowadays always recorded in localtime.
      */
+    zone_old = NULL;
     if (zone != NULL && zone[0] != '\0') {
         zone_old = getenv("TZ");
         if (setenv("TZ", zone, 1) != 0)
@@ -752,9 +753,9 @@ tvips_readoutgeometry_tiff(const struct tvips_tiff *handle)
 int
 tvips_read_header(struct tvips_tiff *handle)
 {
-    uint32 *offset;
+    uint32_t *offset;
     uint32_t version;
-    uint16 count;
+    uint16_t count;
 
 
     /* Read the TemData structure using the new tag, which is provided
@@ -796,12 +797,12 @@ tvips_read_header(struct tvips_tiff *handle)
 struct frame *
 tvips_read_tiff(struct tvips_tiff *handle, const char *zone)
 {
-    uint32 binning[2];
+    uint32_t binning[2];
     TIFFErrorHandler error_old, warning_old;
     struct frame *frame;
     size_t i;
-    uint32 length, width;
-    uint16 bps;
+    uint32_t length, width;
+    uint16_t bps;
 
 
     /* Disable errors and warnings, as the former are communicated
--- tvips/tiff2smv.c.orig
+++ tvips/tiff2smv.c
@@ -123,13 +123,12 @@ main(int argc, char *argv[])
     size_t j, nmemb;
     double exposure_max, exposure_min, t;
     float distance, exposure, tilt_rate, wavelength;
-    int all, ch, flip, force, g, g_default, g_opt, i, k, k_opt, verbose;
+    int ch, flip, force, g, g_default, g_opt, i, k, k_opt, verbose;
 
 
     /* Default values for command line options.  The default
      * ReadoutGeometry requires special treatment.
      */
-    all = 0;
     beam_center[0] = NAN;
     beam_center[1] = NAN;
     distance = 2640.0;
@@ -152,7 +151,6 @@ main(int argc, char *argv[])
      */
     static struct option options[] = {
         { "version",          no_argument,       NULL, 'V' },
-        { "all",              no_argument,       NULL, 'a' },
         { "distance",         required_argument, NULL, 'd' },
         { "force",            no_argument,       NULL, 'f' },
         { "readout-geometry", required_argument, NULL, 'g' },
@@ -171,16 +169,12 @@ main(int argc, char *argv[])
     opterr = 0;
     setprogname(argv[0]);
     while ((ch = getopt_long(
-                argc, argv, ":Vad:fg:hk:o:r:vw:x:y:z:", options, NULL)) != -1) {
+                argc, argv, ":Vd:fg:hk:o:r:vw:x:y:z:", options, NULL)) != -1) {
         switch (ch) {
         case 'V':
             version();
             return (EXIT_SUCCESS);
 
-        case 'a':
-            all = 1;
-            break;
-
         case 'd':
             errno = 0;
             distance = strtof(optarg, &ep);
